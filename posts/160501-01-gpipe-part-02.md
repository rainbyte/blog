---
title: Programación de GPU en Haskell usando GPipe - Parte 2
author: rainbyte
published: 2016-04-27 03:23:00
tags: gpipe, gpu, haskell, opengl
language: es
---

Nota: estas leyendo la traducción al castellano de una serie de tutoriales en ingles sobre GPipe; la versión original, escrita por Tobias Bexelius (creador de GPipe), se encuentra [aqui](http://tobbebex.blogspot.com.ar/2015/09/gpu-programming-in-haskell-using-gpipe_11.html).

[< Episodio previo: Hello triangle](/posts/160426-01-gpipe-part-01.html)

¡Bienvenido nuevamente! En la ultima parte obtuviste tu primer triangulo mediante GPipe. Esta vez vamos a examinar `Buffer` y `PrimitiveArray` con más detalle.

## Buffers

En el ejemplo "HEllo world" que hicimos la ultima vez, usamos un `Buffer` para almacenar las posiciones y colores del triangulo. A partir de este buffer, creamos un `PrimitiveArray` que enviamos al shader. Más adelante vamos a ver que un `Buffer` puede ser usado tambien para otras cosas.

Un `Buffer` en GPipe es un array de datos que esta almacenado en la GPU. Es mutable, asi como `IOArray` o `STArray`, y asi como aquellos tambien vive en una monada, en este caso la monada `ContextT`. Veamos primero la función que se encarga de crear buffers:

```haskell
newBuffer :: (MonadIO m, BufferFormat b) => Int -> ContextT w os f m (Buffer os b)
```

Un buffer tiene tipo `Buffer os b`, donde `os` es el mismo que el de `ContextT`. Como puedes recordar desde la ultima vez, este parametro de tipo `os` es usado para evitar que los objetos asociados a un contexto puedan escapar de la monada, y `Buffer` es uno de esos objetos. 

`newBuffer` solo toma un argumento: el numero de elementos a crear en el buffer. Un buffer tiene elementos mutables, pero el numero de elementos es inmutable. El tipo de los elementos del buffer se denota con `b`, y puedes ver que este `b` esta delimitado por el typeclass `BufferFormat b`. Antes de mostrarte ese typeclass, miremos la función que vas a usar para llenar el buffer con datos desde el lado de la CPU:

```haskell
writeBuffer :: MonadIO m => Buffer os b -> BufferStartPos -> [HostFormat b] -> ContextT w os f m ()
```

Esta función toma un buffer para escribir y una posicion de inicio con indice basado en cero, nada extraño en esto, pero luego toma una lista de `HostFormat b`... ¿Que ocurre con esto? Los contenidos de un buffer no tienen la misma representación en el host que en el buffer, el cual vive en la GPU (desde ahora voy a usar el termino **host** cuando me refiero al entorno normal de Haskell que vive en la CPU, en contraposición al mundo de la GPU). `HostFormat b` es un tipo al typeclass `BufferFormat b`. Miremos ese typeclass:

```haskell
class BufferFormat f where
  type HostFormat f
  toBuffer :: ToBuffer (HostFormat f) f
```

El unico proposito de esta clase, es proveer una representación para el tipo de los elementos del buffer en el host, asi como una conversión de la representación del host a la del buffer. Aqui hay algunos ejemplos de instancias de esta clase, y sus representaciones en el host:

| f         | HostFormat f                 |
|-----------|------------------------------|
| B Float	| Float                        |
| B Int32	| Int32                        |
| B Word32	| Word32                       |
| B2 Float	| V2 Float                     |
| B2 Int32	| V2 Int32                     |
| B2 Word32	| V2 Word32                    |
| B2 Int16	| V2 Int16                     |
| B2 Word16	| V2 Word16                    |
| (a, b)	| (HostFormat a, HostFormat b) |
| V2 a		| V2 (HostFormat a)            |

Hay muchas más instancias, incluyendo `B3`, `B4` y tuplas mas grandes. Mira la lista completa [en hackage](https://hackage.haskell.org/package/GPipe-2.0.1/docs/Graphics-GPipe-Buffer.html#t:BufferFormat).

Un `Float` en el host se convertirá `B Float` en el `Buffer`. `B a` es un tipo opaco de cual no puedes inspeccionar su valor o hacer ningun calculo, por ej. no hay instancia de `Num` para `B Float`. Para `Buffer` no se expone una manera de aplicar funciones en sus elementos de ninguna manera (por ej. `Buffer` no posee instancia del typeclass `Functor`), pero vamos a crear pronto un `VertexArray` a partir de nuestro `Buffer` y entonces será distinto.

GPipe tambien define los tipos `B2 a`, `B3 a` y `B4 a`. For un conjunto selecto de `a`, `B2 a` es la representación en el buffer de un `V2 a` en el host. `V2 a` es tambien una instancia de `BufferFormat` con `V2 (HostFormat a)` como representación en el host, lo cual significa que tanto `V2 (B Float)` como `B2 Float` tienen la misma representación en el host: `V2 Float`. Ambos formatos de buffer tienen el mismo tamaño e incluso disposición interna, pero `B2 Float` puede ser usado de manera más eficiente como vamos a ver luego.  Por esta razon, siempre instenta usar tipos B en vez de tipos V en los buffers, cuando sea posible. Entonces, ¿porque hay una instancia de `BufferFormat` para `V2`? El caso de uso principal es el de las matrices, por ej. `V4 (V4 Float)` en el host puede almacenarse en un buffer como `V4 (B4 Float)`.

Otra cosa interesante que puedes haber notado al estudiar la lista de instancias de `BufferFormat`, es que hay instancias de `B2 Int16` y `B2 Word16`, pero no de `B Int16` ni `B Word16`. Esto es porque los atributos de los vertices tienen que estar alineadoas a 4 bytes en algunas piezas de hardware, y GPipe respeta esto en sus tipos de datos. `Int16` y `Word16` son ambos de 2 bytes, asi que necesitas tener un vector de al menos dos de ellos. Hay instancias de `B3 Int16` y `B3 Word16`, pero estas poseen un relleno (padding) de 2 bytes extra. La motivación para esto es que siempre podrias usar `B Int32` en vez de `B Int16` si existiese, funcionarian con los mismos shaders y serian del mismo tamaño de todas formas si agregasmos el relleno para el segundo. Por otra parte, un `B3 Int32` toma 12 bytes mientras que un `B3 Int16` con relleno includo solo ocupa 8 bytes, asi que hay un caso distintivo para este ultimo. Un `B4 Int16` tambien utiliza 8 bytes, pero no funcionaria con los mismos shaders, como va a ser evidente en la siguiente parte de este tutorial.

Ahora miremos el miembro `toBuffer` del typeclass `BufferFormat`. Posee el tipo `ToBuffer (HostFormat f) f`. `ToBuffer` es algo llamodo **arrow** en Haskell. Es como una función (en este caso `HostFormat f -> f`), pero más general. Echemos un vistazo a la instancia `BufferFormat (a, b)` como ejemplo:

```haskell
{-# LANGUAGE Arrows #-}

instance (BufferFormat a, BufferFormat b) => BufferFormat (a, b) where
  type HostFormat (a,b) = (HostFormat a, HostFormat b)
  toBuffer = proc ~(a, b) -> do
                a' <- toBuffer -< a
                b' <- toBuffer -< b
                returnA -< (a', b')
```

La notacion arrow casi se parece a un lambda (usando el keyword especial `proc`) retornando una acción monadica. Pero no es una monada. La mayor diferencia con una monada es que no puede seleccionar una acción basandose en los valores de retorno del arrow. Es por esto que las acciones de un arrow poseen una cola (`-<`); cualquier cosa entre las partes `<-` y `-<` de un arrow, no puede referenciar nada fuera de ellas (`a`, `b`, `a'`, `b'` en este caso). Esto obliga a que toda invocación a `toBuffer` deba ir a travez de la misma serie de acciones de arrow, independientemente de los valores de entrada reales. Otro requerimiento adicional que tiene GPipe, es que necesita ser capaz de producir valores de forma lazy, es por ello el tilde (`~`) en el patrón `proc`. La unicas acciones del arrow `ToBuffer` que GPipe define para usar en tu propia implementación de `toBuffer`, son los metodos `toBuffer` de otras instancias. Vas a ver aparecer este patrón, donde un arrow es usado para definir la conversión entre dos dominios, en varios lugares de GPipe a medida continuemos con el tutorial.

## Arrays de vertices

Bueno, ¡ahora eres un experto en buffers! Vamos a darles algun uso:


```haskell
newVertexArray :: Buffer os a -> Render os f (VertexArray t a)
```

Ejecutas esta función en una monada `Render` para crear un `VertexArray t a`. Un array de vertices es como la vista de un buffer, y `newVertexArray` no copia ningun dato. Ya que operamos dentro de la monada `Render` (que es ejecutada por la función render, la cual no permite valores de retorno), y un `Buffer` solo puede ser modificado fuera de esta monada (en la monada `ContextT`), conceptualmente podrias pensar a `VertexArray` como una copia del `Buffer`. No lo es realmente, pero puedes tratarlo como una.

`VertexArray t a` es un array de vertices donde cada vertice es un elemento de tipo `a`, que es el mismo tipo de los elementos del `Buffer` a partir del cual lo creaste. No te preocupes por el parametro `T` por ahora, vamos a llegar a eso en un momento. El `VertexArray` posee tantos vertices como elementos pertenecientes al `Buffer` que lo origina, pero en constraste a este ultimo, puedes recortar un `VertexArray` usando las funciones `dropVertices` o `takeVertices`. Estas funcionan exactamente como `drop` o `take` trabajan sobre listas normales:

```haskell
takeVertices :: Int -> VertexArray t a -> VertexArray t a Source
dropVertices :: Int -> VertexArray () a -> VertexArray t a Source
```

`VertexArray` tambien tiene una instancia de `Functor`, la cual permite aplicar `fmap` sobre los vertices. ¡Aqui es donde la opacidad de los tipos B entran en juego! Ahora que puedes hacer cosas con tus valores B, vas a notar que las opciones sob algo limitadas. Puedes simplemente agarrar elementos de estructuras como tuplas y/o construir nuevas estructuras con los valores que posees. A pesar de esto, hay un par de funciones que operan sobre valores B que puedes usar aqui:

```haskell
toB22 :: forall a. (Storable a, BufferFormat (B2 a)) => B4 a -> (B2 a, B2 a)
toB3 :: forall a. (Storable a, BufferFormat (B3 a)) => B4 a -> B3 a
toB21 :: forall a. (Storable a, BufferFormat (B a)) => B3 a -> (B2 a, B a)
toB12 :: forall a. (Storable a, BufferFormat (B a)) => B3 a -> (B a, B2 a)
toB11 :: forall a. (Storable a, BufferFormat (B a)) => B2 a -> (B a, B a)
```

Estas permiten separar vectores B en partes mas pequeñas. Fijate que de todos modos no hay funciones que puedan combinarlas nuevamente.

Puedes tambien hacer comprimir (zip) dos `VertexArray` juntos, con la función `zipVertices`, que funciona exactamente como `zipWith` para listas normales; provees una función para combinar los elementos de ambos argumentos `VertexArray` y el resultante sera del tamaño del más pequeño de ambos arrays:

```haskell
zipVertices :: (a -> b -> c) -> VertexArray t a -> VertexArray t' b -> VertexArray (Combine t t') c
```

*(Nuevamente, no te preocupes por el extraño primer parametro en el VertexArray retornado, lo explicaré más adelante)*

Comprimir arrays de vertices es lo que se corresponde con usar arrays no-intercalados (non-interleaved) en OpenGL, mientras que un array de vertices desde un solo buffer de un tipo de elementos compuestos (asi como una tupla de dos valores B) corresponde a arrays intercalados (interleaved). ¡Esta es solo la manera funcional y type safe de hacerlo!

## Arrays de primitivas

Ahora que haz recortado (trim), comprimido (zip) y mapeado (fmap) tus arrays de vertices a la perfección, es hora de crear un array de primitivas. La manera más simple de crear uno es con esta función:

```haskell
toPrimitiveArray :: PrimitiveTopology p -> VertexArray () a -> PrimitiveArray p a
```

Siempre vas a necesitar una topologia de primitivas, ademas de tu array de vertices, para crear un `PrimitiveArray`. La topologia de primitivas detota como los vertices deben conectarse para formar primitivas, y es uno de estos constructores:

```haskell
data PrimitiveTopology p where
  TriangleList :: PrimitiveTopology Triangles
  TriangleStrip :: PrimitiveTopology Triangles
  TriangleFan :: PrimitiveTopology Triangles
  LineList :: PrimitiveTopology Lines
  LineStrip :: PrimitiveTopology Lines
  LineLoop :: PrimitiveTopology Lines
  PointList :: PrimitiveTopology Points
```

En la mayoria de los casos vas a trabajar con triangulos. Veamos como se ven las tres topologias de triangulos:

![(a) - TriangleStrip, (b) - TriangleFan, (c) - TriangleList  
(Image courtesy of OpenGL specification by Khronos)](/images/gpipe-part-02-triangle-topologies.png)

En un `TriangleStrip`, cada vertice forma un triangulo con los dos vertices previos, alternando el camino de los vertices para cada triangulo. Esto significa que el primer triangulo es formado por los vertices 1-2-3 en ese orden, el siguiente por 2-4-3, luego por 3-4-5, 4-6-5, y asi sucesivamente. Para `TriangleFan`, cada triangulo es formado por el primer vertice en el array junto con cada dos vertices consecutivos, en ese orden. Para `TriangleList`, cada tres vertices simplemente forman un triangulo; no se comparte ningun vertice entre los triangulos.

Los vertices siempre vienen en orden antihorario para un triangulo de cara orientada hacia el frente (lo cual significa que todos los triangulos en la imagen de arriba, excepto el de más a la derecha, estan orientados con cara hacia el fondo; solo como ejemplo de cuan intuitiva puede ser la especificación de OpenGL). La orientación de la cara de un triangulo va a ser importante luego, cuando lo rastericemos, en ese momento podras elegir solo rasterizar los triangulos de cara hacia el frente o hacia el fondo. 

Los arrays de primitivas no se pueden recortar como los de vertices, pero poseen una instancia de `Functor` asi que puedes hacer `fmap` sobre ellos exactamente como con los arrays de vertices. Tambien tienen una instancia de `Monoid`, que permite concatenar dos `PrimitiveArray` juntos en uno solo usando `mappend`. Esto hace posible crea un `PrimitiveArray` conformado por varias tiras de triangulos disjuntas, pero maneras más eficientes de lograrlo serán presentadas en las siguientes dos secciones.

## Arrays de indices

